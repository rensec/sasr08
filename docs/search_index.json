[["index.html", "SaSR 8: Social Network Analysis About Usage Credits and further resources", " SaSR 8: Social Network Analysis Rense Corten 2024-04-08 About This page contains tutorials for the Utrecht University course SaSR 8/Research practicum 2: Social network analysis (200400071). Usage To use these tutorials, we suggest that you : Open new R script; Copy-paste the code from the tutorials into your R script as you read along; Run the code from your script while reading along, to verify that your results are the same; Afterwards, save your R-script under an informative name so that you can refer to it and reuse it later. A big part of effective data analysis is realizing that you’ve solved particular problems before and being able to find and recycle your earlier code! Credits and further resources There are many excellent tutorials for social network analysis in R, and the tutorials on this page is inspired by and builds on some of them. Particularly useful were: The tutorials that accompany the book Network Analysis: Integrating Social Network Theory, Method, and Application with R by Craig Rawlings, Jeffrey A. Smith, James Moody, and Daniel McFarland (2023); The tutorials that accompany the book Analyzing Social Networks Using R by Stephen Borgatti, Martin Everett, Jeffrey Johnson and Filip Agneessens; The tutorials available on the Statnet website, created by the Statnet team. "],["handling-social-network-data-in-r.html", "1 Handling social network data in R 1.1 Getting network data into R: the igraph package 1.2 The reverse direction: exporting from igraph objects 1.3 Getting network data into R: the network package 1.4 Modifying networks in igraph", " 1 Handling social network data in R This R notebook demonstrates some data handling procedures for relational (social network) data, especially data as generated by “name generator” questionnaires. We start by loading some useful packages: igrapg and network are packages specifically for handling network data; reshape2 and tidyverse are more general-purpose packages that included useful procedures. NOTE: if you get any “there is no package called…” error messages, make sure you install these packages first using the install.packages() function (not included here). library(network) library(igraph) library(reshape2) library(tidyverse) 1.1 Getting network data into R: the igraph package We start by reading some network data from disk (or from the internet, in this case). A simple and very common way to store data is as “comma-separated values” (CSV). Let’s load some “toy data”: url1 &lt;- &quot;https://github.com/rensec/sasr08/raw/main/g_adj_matrix_simple.csv&quot; g_matrix &lt;- read.csv(file = url1, header = FALSE) g_matrix ## V1 V2 V3 V4 V5 ## 1 0 1 0 1 0 ## 2 0 0 1 0 0 ## 3 1 0 0 0 0 ## 4 0 0 0 0 0 ## 5 0 0 0 0 0 These data are stored as an adjacency matrix. While reading the data, R automatically created column names and loaded the data as a data frame: class(g_matrix) ## [1] &quot;data.frame&quot; For network analysis, this is often not practical; for example we may want to do matrix calculations. So instead, let’s turn this into a matrix object: g_matrix &lt;- as.matrix(g_matrix) g_matrix ## V1 V2 V3 V4 V5 ## [1,] 0 1 0 1 0 ## [2,] 0 0 1 0 0 ## [3,] 1 0 0 0 0 ## [4,] 0 0 0 0 0 ## [5,] 0 0 0 0 0 For clarity, we also add row- and column names, simply numbering them: rownames(g_matrix) &lt;- 1:nrow(g_matrix) colnames(g_matrix) &lt;- 1:ncol(g_matrix) g_matrix ## 1 2 3 4 5 ## 1 0 1 0 1 0 ## 2 0 0 1 0 0 ## 3 1 0 0 0 0 ## 4 0 0 0 0 0 ## 5 0 0 0 0 0 QUESTION: How many nodes are included in this matrix, and how many edges are there between these nodes? Typically, information about nodes and edges are stored in separate files. In our next step, we’re reading an attribute of the nodes: g_nodes_age &lt;- read.csv(file = &quot;https://github.com/rensec/sasr08/raw/main/g_nodes_age.csv&quot;) g_nodes_age ## id age ## 1 1 20 ## 2 2 21 ## 3 3 25 ## 4 4 NA ## 5 5 21 We now have information about nodes and edges loaded in R . However, to R, these are just like any data; it doesn’t “know” that these are network data. In order to be able to use specific SNA procedures, we first need to create network objects, which is what we’ll do next. NOTE: the data that we’ve loaded now just happened to be stored as an adjacency matrix; it is also possible to store network data on disk in other formats. We’ll get to that later. 1.1.1 Creating network objects in igraph Network analysis packages such as igraph handle data efficiently by storing data in their own type of objects, which basically ensure that all procedures make sense for network data. A network object as used by igraph includes the information on both edges and nodes of a network in a single “box” (and potentially other information about the network too). To create an igraph network object from our matrix object we run: g &lt;- graph_from_adjacency_matrix(g_matrix) class(g) ## [1] &quot;igraph&quot; g ## IGRAPH 1461064 DN-- 5 4 -- ## + attr: name (v/c) ## + edges from 1461064 (vertex names): ## [1] 1-&gt;2 1-&gt;4 2-&gt;3 3-&gt;1 The output from running “g” already shows that this is now a network object (specifically: an object of the class “igraph”, as shown by class()): R interprets the object as a network and shows us the edges in the network. This also means that other R functions - to the extent that they have network methods implemented - now automatically recognize g as a network object and will behave accordingly (note that this is a key feature of R as an “object-oriented language”). For example, we can now run the standard plot() function and it will create a network map: plot(g) Now we can also add node attributes to the object (in this case we have only one): g &lt;- set_vertex_attr(g, name = &quot;age&quot;, value = g_nodes_age$age) 1.1.2 Creating network objects from adjacency list data A common format for network data, especially if collected via survey methods, is the adjacency list. In this format, we have a row for each node, and columns that indicate the first, second, third…etc connection of each node. The file g_adj_list.csv is an example of this format (it is again our toy network as used in the previous excercises). g_adj_list &lt;- read.csv(file = &quot;https://github.com/rensec/sasr08/raw/main/g_adj_list.csv&quot;) g_adj_list ## id age friend1 friend2 ## 1 1 20 2 4 ## 2 2 21 3 NA ## 3 3 25 1 NA ## 4 4 NA NA NA ## 5 5 21 NA NA Note that: The columns “friend1” and “friend2” could, for example, refer to “name generator” survey questions, where each node number in the column refers to a friend “nominated” by the node (respondent) in the corresponding row. In this case, the nodes can have at most two (outgoing) ties. This format allows for easy inclusion of node attributes as well, such as, in this case, the column “age”. The most convenient way to create a network object from these data, is to first transform them into an edge list, as this is a format for which igraph has an import function, such that we can turn it into a network object. To create an edge list, we first make the data long. g_elist_from_alist &lt;- g_adj_list %&gt;% select(id, friend1:friend2) %&gt;% #keep only the network variables (and id) melt( id.vars = &quot;id&quot;) #from the reshape2 package g_elist_from_alist ## id variable value ## 1 1 friend1 2 ## 2 2 friend1 3 ## 3 3 friend1 1 ## 4 4 friend1 NA ## 5 5 friend1 NA ## 6 1 friend2 4 ## 7 2 friend2 NA ## 8 3 friend2 NA ## 9 4 friend2 NA ## 10 5 friend2 NA We could do the same using the tidyr package (automatically loaded with tidyverse: g_adj_list %&gt;% # (we don&#39;t save it into an object as above this time, since we just want to show that the result is the same) select(id, friend1:friend2) %&gt;% #keep only the network variables (and id) pivot_longer(c(friend1, friend2)) ## # A tibble: 10 × 3 ## id name value ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 1 friend1 2 ## 2 1 friend2 4 ## 3 2 friend1 3 ## 4 2 friend2 NA ## 5 3 friend1 1 ## 6 3 friend2 NA ## 7 4 friend1 NA ## 8 4 friend2 NA ## 9 5 friend1 NA ## 10 5 friend2 NA To create an edge list we subsequently drop all missing values on “value” and do some housekeeping: g_elist_from_alist &lt;- g_elist_from_alist%&gt;% filter(!is.na(value)) %&gt;% # drop the missings rename(from =&quot;id&quot;, to = &quot;value&quot;, sourcevar= &quot;variable&quot;) %&gt;% #just nice for interpretation relocate(to, .after=from) #move around the columns g_elist_from_alist ## from to sourcevar ## 1 1 2 friend1 ## 2 2 3 friend1 ## 3 3 1 friend1 ## 4 1 4 friend2 We can now interpret each {from,to} combination as a directed edge (tie) from respondent to alter; sourcevar is an edge attribute indicating where in the adjacency list columns the alter was mentioned. Strictly speaking you don’t need the latter for a simple edge list, but it’s useful to keep in case you want to reverse the procedure. QUESTION: Besides useful more data manipulation procedures, keeping the information in sourcevar could also be important for more substantive reasons. Can you think of such a reason? Now we can import this into a network object with an igraph function: g_from_elist &lt;- graph_from_data_frame(g_elist_from_alist) #This is a proper igraph graph object plot(g_from_elist) Note however that we lost the isolate! To include the isolate, we need to feed the function also the list of all the nodes: nodelist &lt;- select(g_adj_list,id,age) g_from_elist &lt;- graph_from_data_frame(g_elist_from_alist, vertices = nodelist) #This is a proper igraph graph object plot(g_from_elist) That’s better! Note that besides the node IDs, we also include the age variable in the network object as a node attribute, such that we could use it in analyses based on the network object. 1.2 The reverse direction: exporting from igraph objects Handling your network data as igraph objects is useful for social network analysis, but sometimes we also want to transform our data back from network objects to “regular” matrix objects or data frames. We briefly cover some of these cases here. 1.2.1 From igraph to adjacency matrix g_adj_matrix &lt;- as_adjacency_matrix(g, sparse = FALSE) g_adj_matrix ## 1 2 3 4 5 ## 1 0 1 0 1 0 ## 2 0 0 1 0 0 ## 3 1 0 0 0 0 ## 4 0 0 0 0 0 ## 5 0 0 0 0 0 We here specify sparse = FALSE because by default, as_adjacency_matrix() will return a “sparse matrix” (just run as_adjacenct_matrix(g) on your R console and see what comes out), which is a somewhat more efficient way of handling matrices with many zeroes. To demonstrate that we can recreate our original adjacency matrix however, we don’t want that here. To check whether the resulting matrix is indeed identical to what we originally read from disk we can do: all(g_adj_matrix == g_matrix) ## [1] TRUE 1.2.2 From igraph to edge list g_edgelist &lt;- igraph::as_data_frame(g_from_elist, what = &quot;edges&quot;) g_edgelist ## from to sourcevar ## 1 1 2 friend1 ## 2 2 3 friend1 ## 3 3 1 friend1 ## 4 1 4 friend2 Note the use of the “namespace” “igraph::” here, to indicate that we need the igraph function here, not the function with the same name from the dplyr/tidyverse package Note that now, once more, we have lost our isolated node 5! To get all nodes, we could simply run: igraph::as_data_frame(g_from_elist, what = &quot;vertices&quot;) ## name age ## 1 1 20 ## 2 2 21 ## 3 3 25 ## 4 4 NA ## 5 5 21 1.2.3 From igraph to adjacency list edgelist_2 &lt;- igraph::as_data_frame(g_from_elist, what = &quot;edges&quot;) nodelist_2 &lt;- igraph::as_data_frame(g_from_elist, what = &quot;vertices&quot;) # Note the use of the &quot;namespace&quot; &quot;igraph::&quot; here, to indicate that we need the igraph function here, not the function with the same name from the dplyr/tidyverse package d &lt;- edgelist_2 %&gt;% rename(id = &quot;from&quot;) %&gt;% pivot_wider( id_cols = id, names_from = sourcevar, values_from = to ) %&gt;% merge(nodelist_2, by.x = &quot;id&quot;, by.y = &quot;name&quot;, all.y = TRUE ) %&gt;% relocate(age, .after = id) %&gt;% type_convert() #as_data_frame returns characters; this transforms it back to numeric ## ## ── Column specification ───────────────────────────────────────────────────────────────────────────────────────────────── ## cols( ## id = col_double(), ## friend1 = col_double(), ## friend2 = col_double() ## ) d ## id age friend1 friend2 ## 1 1 20 2 4 ## 2 2 21 3 NA ## 3 3 25 1 NA ## 4 4 NA NA NA ## 5 5 21 NA NA …and we’re back! 1.3 Getting network data into R: the network package An alternative to igraph is the network package, which has its own type of network data object (as used by, for example, the sna and ergm packages), and its own set of functions for handling network data. Note that we’ve already loaded the network package at the start of the tutorial. We can import our data into a network object (using the edge list that we’ve created before) as follows: g_np &lt;- as.network(g_elist_from_alist, matrix.type = &quot;edgelist&quot;, vertices = nodelist) g_np ## Network attributes: ## vertices = 5 ## directed = TRUE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## bipartite = FALSE ## total edges= 4 ## missing edges= 0 ## non-missing edges= 4 ## ## Vertex attribute names: ## age vertex.names ## ## Edge attribute names: ## sourcevar plot(g_np) We don’t discuss network in-depth for now; it suffices to say that the choice between igraph and network will typically depend on the specific needs of your research project. Both packages include a large set of functions for handling network data, but as igraph is a bit more comprehensive in terms of functions for network analysis, it tends to be somewhat more popular. There are also companion packages for network that allow various types of analyses, included in the statnet suite. Finally, for converting between network- and igraph- objects, look at intergraph. 1.4 Modifying networks in igraph We now turn back to igraph. Once we have our data wrapped into a network object, we can use igraph functions to make changes to the data. For example, we may remove a node: g_mod &lt;- delete_vertices(g,2) plot(g_mod) This simple operation illustrates the power of handling networks as network objects: teh igraph function delete_vertices() “understands” that removing a node from a network logically implies that also the edges connected to this node should be removed. If you would have to do this with, say, a raw edge list or adjacency list, it would be much more cumbersome! The same function also takes a vector of node IDs. For example, to remove all nodes with age = 21, we could do: g_mod &lt;- delete_vertices(g,which(V(g)$age == 21)) plot(g_mod) In the above code, we use the igraph function V() to get all vertices of the graph. QUESTION:: Write the code to remove all nodes from g for which age is missing. We have already seen the use of set_vertex_attr() to add node attributes, of V() to get all nodes. As an alternative to set_vertex_attr(), we can also use V() for the same purpose: V(g)$gender &lt;- c(&quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;other&quot;, &quot;male&quot;) g ## IGRAPH 1461064 DN-- 5 4 -- ## + attr: name (v/c), age (v/n), gender (v/c) ## + edges from 1461064 (vertex names): ## [1] 1-&gt;2 1-&gt;4 2-&gt;3 3-&gt;1 Similarly, we can use E() to access, add and modify edge attributes. For more information on all the graph manipulation functions included in igraph, see the package’s website and, of course, the help pages in R. "],["basic-network-analysis-in-r.html", "2 Basic network analysis in R 2.1 Network level: a “five number summary” 2.2 Individual level: centrality", " 2 Basic network analysis in R In this tutorial we’ll use the igraph package to do some basic descriptive social network analysis. Obviously, we can only scratch the surface here, and many research project will require different analyses. Also, we do not cover visualization specifically. As an example network, we’ll use the famous “karate club” data studied by Zachary (1977), included with igraph. library(igraph) z &lt;- make_graph(&quot;Zachary&quot;) z ## IGRAPH 15414c8 U--- 34 78 -- Zachary ## + attr: name (g/c) ## + edges from 15414c8: ## [1] 1-- 2 1-- 3 1-- 4 1-- 5 1-- 6 1-- 7 1-- 8 1-- 9 1--11 1--12 ## [11] 1--13 1--14 1--18 1--20 1--22 1--32 2-- 3 2-- 4 2-- 8 2--14 ## [21] 2--18 2--20 2--22 2--31 3-- 4 3-- 8 3--28 3--29 3--33 3--10 ## [31] 3-- 9 3--14 4-- 8 4--13 4--14 5-- 7 5--11 6-- 7 6--11 6--17 ## [41] 7--17 9--31 9--33 9--34 10--34 14--34 15--33 15--34 16--33 16--34 ## [51] 19--33 19--34 20--34 21--33 21--34 23--33 23--34 24--26 24--28 24--33 ## [61] 24--34 24--30 25--26 25--28 25--32 26--32 27--30 27--34 28--34 29--32 ## [71] 29--34 30--33 30--34 31--33 31--34 32--33 32--34 33--34 plot(z) This looks like an undirected network, which we can verify using: is_directed(z) ## [1] FALSE 2.1 Network level: a “five number summary” A good starting point of any network analysis project is to look at some basic properties of the graph as a whole. While there are many potentially interesting properties, we’ll focus here on the the “five number summary” as suggested by Luke (2015). 2.1.1 Size Probably the most basic property of a network is its size, that is, the number of vertices and the number of edges. While igraph already reported them above (if you knew where to look), we can ask for these numbers specifically: ecount(z) ## [1] 78 vcount(z) ## [1] 34 2.1.2 Density The density of a network is the ratio of existing edges and the maximum possible number of edges that could exist, given the number of vertices. We can let R calculate it for us: edge_density(z) ## [1] 0.1390374 Obviously, we could already have calculated this ourselves, given that we already knew the number of edges and the number of vertices. QUESTION: How would you calculate density using ecount() and vcount()? If desired, we can also add such network-level results to the network object, for later use: z$density &lt;- edge_density(z) z ## IGRAPH 15414c8 U--- 34 78 -- Zachary ## + attr: name (g/c), density (g/n) ## + edges from 15414c8: ## [1] 1-- 2 1-- 3 1-- 4 1-- 5 1-- 6 1-- 7 1-- 8 1-- 9 1--11 1--12 ## [11] 1--13 1--14 1--18 1--20 1--22 1--32 2-- 3 2-- 4 2-- 8 2--14 ## [21] 2--18 2--20 2--22 2--31 3-- 4 3-- 8 3--28 3--29 3--33 3--10 ## [31] 3-- 9 3--14 4-- 8 4--13 4--14 5-- 7 5--11 6-- 7 6--11 6--17 ## [41] 7--17 9--31 9--33 9--34 10--34 14--34 15--33 15--34 16--33 16--34 ## [51] 19--33 19--34 20--34 21--33 21--34 23--33 23--34 24--26 24--28 24--33 ## [61] 24--34 24--30 25--26 25--28 25--32 26--32 27--30 27--34 28--34 29--32 ## [71] 29--34 30--33 30--34 31--33 31--34 32--33 32--34 33--34 ‘Density’ is now listed as one of the attributes of the object, where ‘g/n’ indicates that it is a graph-level attribute. 2.1.3 Components The number of components is the number of unconnected parts of the network (which may be parts consisting of one node, that is, isolates). The number of components in this network is, quite trivially, just one, but the way to get it is: count_components(z) ## [1] 1 2.1.4 Diameter (and distances) The diameter of a network is the “longest shortest path” in the network diameter(z) ## [1] 5 A related an much-studied property is the average shortest path length, that is, the average of all the shortest path over all pairs of vertices in the network. For example, this is the key indicator in the “small world phenomenon”. mean_distance(z) ## [1] 2.4082 2.1.5 Clustering Coefficient Clustering, or transitivity, relates to the extent to which triangles tend to be closed in the network, or put differently, to what extent neighbors of nodes tend to be connected themselves. There are many ways to quantify this tendency (which also differ for directed an undirected networks), and the transitivity() function covers many of them. Note that in the literature and elsewhere in the field, terms like ‘transitivity’ and ‘clustering’ are often used quite loosely, so it is always wise to look closely at the formal specifications (if provided) to know what is meant in a specific use case. We here compute what is most commonly known as the ‘clustering coefficient’. This computes, for each vertex, the proportion of the potential ties between the vertex’ neighbors that actually exist (in the ego networks literature, this is referred to as local density), and averages this over all vertices. transitivity(z, type=&quot;average&quot;) ## [1] 0.5879306 Interestingly, the specification of ‘average’ for the ‘type’ parameter is not explained in the igraph documentation, but this is what it does. 2.2 Individual level: centrality Moving to the individual (that is, node-level) measures, we concentrate here on centrality measures. Obviously, there are many other measures related to individual network position that may be relevant (and are included in igraph, see the reference manual). 2.2.1 Degree centrality The most straightforward measure of centrality is degree centrality, or simply the number of connections per node. We obtain it using the degree() function from igraph: degree(z) ## [1] 16 9 10 6 3 4 4 4 5 2 3 1 2 5 2 2 2 2 2 3 2 2 2 5 3 ## [26] 3 2 4 3 4 4 6 12 17 Because degree is an individual-level property, the result from the function is no longer a single number as before, but a vector of numbers, one for each node. Of course we can use this vector for further calculations: summary(degree(z)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.000 2.000 3.000 4.588 5.000 17.000 hist(degree(z)) (Note that there are of course much nicer and better ways to analyze and visualize distributions like this, but that is not the point of this tutorial.) In many other cases, we’d want to keep the individual-level results on centrality and add them to the network object for later use: V(z)$degree &lt;- degree(z) We may, for example, want to use it in a plot: #We add + 8 to degree to avoid that the lowest-degree nodes become really small and specify margin = -0.1 to reduce the whitespace around the plot plot(z, vertex.size = V(z)$degree+8, margin= -0.1) Finally, if you run ?degree() on your console, you’ll note that the function has a number of other useful options. For example, we can also extract the degree of a specific vertex: degree(z, v = 3) ## [1] 10 Furthermore, for directed networks, you can also specify whether you want indegree, outdegree, or the total degree (but that does not apply to our undirected example network). 2.2.2 Betweenness centrality A fancier centrality measure is betweenness centrality, which relies on the shortest paths between all pairs of vertices to assess to what extent nodes sit on shortest paths between other nodes. betweenness(z) ## [1] 231.0714286 28.4785714 75.8507937 6.2880952 0.3333333 15.8333333 ## [7] 15.8333333 0.0000000 29.5293651 0.4476190 0.3333333 0.0000000 ## [13] 0.0000000 24.2158730 0.0000000 0.0000000 0.0000000 0.0000000 ## [19] 0.0000000 17.1468254 0.0000000 0.0000000 0.0000000 9.3000000 ## [25] 1.1666667 2.0277778 0.0000000 11.7920635 0.9476190 1.5428571 ## [31] 7.6095238 73.0095238 76.6904762 160.5515873 We again add it to the network object. This time, we use set_vertex_attr() rather than V() just to demonstrate that this may work better in a “pipeline” workflow: z &lt;- z %&gt;% set_vertex_attr( name = &quot;betweenness&quot;, value = betweenness(z) ) 2.2.3 Closeness centrality Finally, we add closeness centrality, which also relies on shortest paths, but instead assesses how close each node is to the other nodes. V(z)$closeness &lt;- closeness(z) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
