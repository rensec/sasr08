[["index.html", "SaSR 8: Social Network Analysis About Usage Credits and further resources", " SaSR 8: Social Network Analysis Rense Corten &amp; Deni Mazrekaj 2024-04-25 About This page contains tutorials for the Utrecht University course SaSR 8/Research practicum 2: Social network analysis (200400071). Usage To use these tutorials, we suggest that you: Open a new R script; Copy-paste the code from the tutorials into your R script as you read along; Run the code from your script while reading along, to verify that your results are the same; Afterwards, save your R-script under an informative name so that you can refer to it and reuse it later. A big part of effective data analysis is realizing that you’ve solved particular problems before and being able to find and recycle your earlier code! Credits and further resources There are many excellent tutorials for social network analysis in R, and the tutorials on this page is inspired by and builds on some of them. Particularly useful were: The tutorials that accompany the book Network Analysis: Integrating Social Network Theory, Method, and Application with R by Craig Rawlings, Jeffrey A. Smith, James Moody, and Daniel McFarland (2023); The tutorials that accompany the book Analyzing Social Networks Using R by Stephen Borgatti, Martin Everett, Jeffrey Johnson and Filip Agneessens; The tutorials available on the Statnet website, created by the Statnet team. "],["handling-social-network-data-in-r.html", "1 Handling social network data in R 1.1 Getting network data into R: the igraph package 1.2 The reverse direction: exporting from igraph objects 1.3 Getting network data into R: the network package 1.4 Modifying networks in igraph", " 1 Handling social network data in R This tutorial demonstrates some data handling procedures for relational (social network) data. In particular, we’ll learn: How to read network data from a file and convert them into a ‘network object’ that R can work with, using the common network-oriented packages igraph and network; How to move back and forth between different types of data formats for relational data; How to perform basic data manipulation procedures in igraph; How to produce a basic visualization of a network. We start by loading some useful packages: igraph and network are packages specifically for handling network data; reshape2 and tidyverse are more general-purpose packages that included useful procedures. NOTE: if you get any “there is no package called…” error messages, make sure you install these packages first using the install.packages() function (not included here). library(network) library(igraph) library(reshape2) library(tidyverse) 1.1 Getting network data into R: the igraph package We start by reading some network data from a file (from the internet, in this case). A simple and very common way to store data is as “comma-separated values” (CSV). Let’s load some “toy data”: url1 &lt;- &quot;https://github.com/rensec/sasr08/raw/main/g_adj_matrix_simple.csv&quot; g_matrix &lt;- read.csv(file = url1, header = FALSE) g_matrix ## V1 V2 V3 V4 V5 ## 1 0 1 0 1 0 ## 2 0 0 1 0 0 ## 3 1 0 0 0 0 ## 4 0 0 0 0 0 ## 5 0 0 0 0 0 These data are stored as an adjacency matrix. While reading the data, R automatically created column names and loaded the data as a data frame: class(g_matrix) ## [1] &quot;data.frame&quot; For network analysis, this is often not practical; for example we may want to do matrix calculations. So instead, let’s turn this into a matrix object: g_matrix &lt;- as.matrix(g_matrix) g_matrix ## V1 V2 V3 V4 V5 ## [1,] 0 1 0 1 0 ## [2,] 0 0 1 0 0 ## [3,] 1 0 0 0 0 ## [4,] 0 0 0 0 0 ## [5,] 0 0 0 0 0 For clarity, we also add row- and column names, simply numbering them: rownames(g_matrix) &lt;- 1:nrow(g_matrix) colnames(g_matrix) &lt;- 1:ncol(g_matrix) g_matrix ## 1 2 3 4 5 ## 1 0 1 0 1 0 ## 2 0 0 1 0 0 ## 3 1 0 0 0 0 ## 4 0 0 0 0 0 ## 5 0 0 0 0 0 QUESTION: How many nodes are included in this matrix, and how many edges are there between these nodes? Typically, information about nodes and edges are stored in separate files. In our next step, we’re reading an attribute of the nodes: g_nodes_age &lt;- read.csv(file = &quot;https://github.com/rensec/sasr08/raw/main/g_nodes_age.csv&quot;) g_nodes_age ## id age ## 1 1 20 ## 2 2 21 ## 3 3 25 ## 4 4 NA ## 5 5 21 We now have information about nodes and edges loaded in R . However, to R, these are just like any data; it doesn’t “know” that these are network data. In order to be able to use specific SNA procedures, we first need to create network objects, which is what we’ll do next. NOTE: the data that we’ve loaded now just happened to be stored as an adjacency matrix; it is also possible to store network data to a file in other formats. We’ll get to that later. 1.1.1 Creating network objects in igraph Network analysis packages such as igraph handle data efficiently by storing data in their own type of objects, which basically ensure that all procedures make sense for network data. A network object as used by igraph includes the information on both edges and nodes of a network in a single “box” (and potentially other information about the network too). To create an igraph network object from our matrix object we run: g &lt;- graph_from_adjacency_matrix(g_matrix) class(g) ## [1] &quot;igraph&quot; g ## IGRAPH 37284bd DN-- 5 4 -- ## + attr: name (v/c) ## + edges from 37284bd (vertex names): ## [1] 1-&gt;2 1-&gt;4 2-&gt;3 3-&gt;1 The output from running “g” already shows that this is now a network object (specifically: an object of the class “igraph”, as shown by class()): R interprets the object as a network and shows us the edges in the network. This also means that other R functions - to the extent that they have network methods implemented - now automatically recognize g as a network object and will behave accordingly (note that this is a key feature of R as an “object-oriented language”). For example, we can now run the standard plot() function and it will create a network map: plot(g) Now we can also add node attributes to the object (in this case we have only one): g &lt;- set_vertex_attr(g, name = &quot;age&quot;, value = g_nodes_age$age) 1.1.2 Creating network objects from adjacency list data A common format for network data, especially if collected via survey methods, is the adjacency list. In this format, we have a row for each node, and columns that indicate the first, second, third…etc connection of each node. The file g_adj_list.csv is an example of this format (it is again our toy network as used in the previous excercises). g_adj_list &lt;- read.csv(file = &quot;https://github.com/rensec/sasr08/raw/main/g_adj_list.csv&quot;) g_adj_list ## id age friend1 friend2 ## 1 1 20 2 4 ## 2 2 21 3 NA ## 3 3 25 1 NA ## 4 4 NA NA NA ## 5 5 21 NA NA Note that: The columns “friend1” and “friend2” could, for example, refer to “name generator” survey questions, where each node number in the column refers to a friend “nominated” by the node (respondent) in the corresponding row. In this case, the nodes can have at most two (outgoing) ties. This format allows for easy inclusion of node attributes as well, such as, in this case, the column “age”. The most convenient way to create a network object from these data, is to first transform them into an edge list, as this is a format for which igraph has an import function, such that we can turn it into a network object. To create an edge list, we first make the data long. g_elist_from_alist &lt;- g_adj_list %&gt;% select(id, friend1:friend2) %&gt;% #keep only the network variables (and id) melt( id.vars = &quot;id&quot;) #from the reshape2 package g_elist_from_alist ## id variable value ## 1 1 friend1 2 ## 2 2 friend1 3 ## 3 3 friend1 1 ## 4 4 friend1 NA ## 5 5 friend1 NA ## 6 1 friend2 4 ## 7 2 friend2 NA ## 8 3 friend2 NA ## 9 4 friend2 NA ## 10 5 friend2 NA We could do the same using the tidyr package (automatically loaded with tidyverse: g_adj_list %&gt;% # (we don&#39;t save it into an object as above this time, since we just want to show that the result is the same) select(id, friend1:friend2) %&gt;% #keep only the network variables (and id) pivot_longer(c(friend1, friend2)) ## # A tibble: 10 × 3 ## id name value ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 1 friend1 2 ## 2 1 friend2 4 ## 3 2 friend1 3 ## 4 2 friend2 NA ## 5 3 friend1 1 ## 6 3 friend2 NA ## 7 4 friend1 NA ## 8 4 friend2 NA ## 9 5 friend1 NA ## 10 5 friend2 NA To create an edge list we subsequently drop all missing values on “value” and do some housekeeping: g_elist_from_alist &lt;- g_elist_from_alist%&gt;% filter(!is.na(value)) %&gt;% # drop the missings rename(from =&quot;id&quot;, to = &quot;value&quot;, sourcevar= &quot;variable&quot;) %&gt;% #just nice for interpretation relocate(to, .after=from) #move around the columns g_elist_from_alist ## from to sourcevar ## 1 1 2 friend1 ## 2 2 3 friend1 ## 3 3 1 friend1 ## 4 1 4 friend2 We can now interpret each {from,to} combination as a directed edge (tie) from respondent to alter; sourcevar is an edge attribute indicating where in the adjacency list columns the alter was mentioned. Strictly speaking you don’t need the latter for a simple edge list, but it’s useful to keep in case you want to reverse the procedure. QUESTION: Besides useful more data manipulation procedures, keeping the information in sourcevar could also be important for more substantive reasons. Can you think of such a reason? Now we can import this into a network object with an igraph function: g_from_elist &lt;- graph_from_data_frame(g_elist_from_alist) #This is a proper igraph graph object plot(g_from_elist) Note however that we lost the isolate! To include the isolate, we need to feed the function also the list of all the nodes: nodelist &lt;- select(g_adj_list,id,age) g_from_elist &lt;- graph_from_data_frame(g_elist_from_alist, vertices = nodelist) #This is a proper igraph graph object plot(g_from_elist) That’s better! Note that besides the node IDs, we also include the age variable in the network object as a node attribute, such that we could use it in analyses based on the network object. 1.2 The reverse direction: exporting from igraph objects Handling your network data as igraph objects is useful for social network analysis, but sometimes we also want to transform our data back from network objects to “regular” matrix objects or data frames. We briefly cover some of these cases here. 1.2.1 From igraph to adjacency matrix g_adj_matrix &lt;- as_adjacency_matrix(g, sparse = FALSE) g_adj_matrix ## 1 2 3 4 5 ## 1 0 1 0 1 0 ## 2 0 0 1 0 0 ## 3 1 0 0 0 0 ## 4 0 0 0 0 0 ## 5 0 0 0 0 0 We here specify sparse = FALSE because by default, as_adjacency_matrix() will return a “sparse matrix” (just run as_adjacenct_matrix(g) on your R console and see what comes out), which is a somewhat more efficient way of handling matrices with many zeroes. To demonstrate that we can recreate our original adjacency matrix however, we don’t want that here. To check whether the resulting matrix is indeed identical to what we originally read from a file we can do: all(g_adj_matrix == g_matrix) ## [1] TRUE 1.2.2 From igraph to edge list g_edgelist &lt;- igraph::as_data_frame(g_from_elist, what = &quot;edges&quot;) g_edgelist ## from to sourcevar ## 1 1 2 friend1 ## 2 2 3 friend1 ## 3 3 1 friend1 ## 4 1 4 friend2 Note the use of the “namespace” “igraph::” here, to indicate that we need the igraph function here, not the function with the same name from the dplyr/tidyverse package Note that now, once more, we have lost our isolated node 5! To get all nodes, we could simply run: igraph::as_data_frame(g_from_elist, what = &quot;vertices&quot;) ## name age ## 1 1 20 ## 2 2 21 ## 3 3 25 ## 4 4 NA ## 5 5 21 1.2.3 From igraph to adjacency list edgelist_2 &lt;- igraph::as_data_frame(g_from_elist, what = &quot;edges&quot;) nodelist_2 &lt;- igraph::as_data_frame(g_from_elist, what = &quot;vertices&quot;) # Note the use of the &quot;namespace&quot; &quot;igraph::&quot; here, to indicate that we need the igraph function here, not the function with the same name from the dplyr/tidyverse package d &lt;- edgelist_2 %&gt;% rename(id = &quot;from&quot;) %&gt;% pivot_wider( id_cols = id, names_from = sourcevar, values_from = to ) %&gt;% merge(nodelist_2, by.x = &quot;id&quot;, by.y = &quot;name&quot;, all.y = TRUE ) %&gt;% relocate(age, .after = id) %&gt;% type_convert() #as_data_frame returns characters; this transforms it back to numeric ## ## ── Column specification ─────────────────────────────────────────────────────────────────────────────────── ## cols( ## id = col_double(), ## friend1 = col_double(), ## friend2 = col_double() ## ) d ## id age friend1 friend2 ## 1 1 20 2 4 ## 2 2 21 3 NA ## 3 3 25 1 NA ## 4 4 NA NA NA ## 5 5 21 NA NA …and we’re back! 1.3 Getting network data into R: the network package An alternative to igraph is the network package, which has its own type of network data object (as used by, for example, the sna and ergm packages), and its own set of functions for handling network data. Note that we’ve already loaded the network package at the start of the tutorial. We can import our data into a network object (using the edge list that we’ve created before) as follows: g_np &lt;- as.network(g_elist_from_alist, matrix.type = &quot;edgelist&quot;, vertices = nodelist) g_np ## Network attributes: ## vertices = 5 ## directed = TRUE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## bipartite = FALSE ## total edges= 4 ## missing edges= 0 ## non-missing edges= 4 ## ## Vertex attribute names: ## age vertex.names ## ## Edge attribute names: ## sourcevar plot(g_np) We don’t discuss network in-depth for now; it suffices to say that the choice between igraph and network will typically depend on the specific needs of your research project. Both packages include a large set of functions for handling network data, but as igraph is a bit more comprehensive in terms of functions for network analysis, it tends to be somewhat more popular. There are also companion packages for network that allow various types of analyses, included in the statnet suite. Finally, for converting between network- and igraph- objects, look at intergraph. 1.4 Modifying networks in igraph We now turn back to igraph. Once we have our data wrapped into a network object, we can use igraph functions to make changes to the data. For example, we may remove a node: g_mod &lt;- delete_vertices(g,2) plot(g_mod) This simple operation illustrates the power of handling networks as network objects: teh igraph function delete_vertices() “understands” that removing a node from a network logically implies that also the edges connected to this node should be removed. If you would have to do this with, say, a raw edge list or adjacency list, it would be much more cumbersome! The same function also takes a vector of node IDs. For example, to remove all nodes with age = 21, we could do: g_mod &lt;- delete_vertices(g,which(V(g)$age == 21)) plot(g_mod) In the above code, we use the igraph function V() to get all vertices of the graph. QUESTION:: Write the code to remove all nodes from g for which age is missing. We have already seen the use of set_vertex_attr() to add node attributes, of V() to get all nodes. As an alternative to set_vertex_attr(), we can also use V() for the same purpose: V(g)$gender &lt;- c(&quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;other&quot;, &quot;male&quot;) g ## IGRAPH 37284bd DN-- 5 4 -- ## + attr: name (v/c), age (v/n), gender (v/c) ## + edges from 37284bd (vertex names): ## [1] 1-&gt;2 1-&gt;4 2-&gt;3 3-&gt;1 Similarly, we can use E() to access, add and modify edge attributes. For more information on all the graph manipulation functions included in igraph, see the package’s website and, of course, the help pages in R. "],["basic-network-analysis-in-r.html", "2 Basic network analysis in R 2.1 Network level: a “five number summary” 2.2 Individual level: centrality", " 2 Basic network analysis in R In this tutorial we’ll use the igraph package to do some basic descriptive social network analysis. Obviously, we can only scratch the surface here, and many research project will require different analyses. Also, we do not cover visualization specifically. As an example network, we’ll use the famous “karate club” data studied by Zachary (1977), included with igraph. library(igraph) z &lt;- make_graph(&quot;Zachary&quot;) z ## IGRAPH 3895987 U--- 34 78 -- Zachary ## + attr: name (g/c) ## + edges from 3895987: ## [1] 1-- 2 1-- 3 1-- 4 1-- 5 1-- 6 1-- 7 1-- 8 1-- 9 1--11 1--12 ## [11] 1--13 1--14 1--18 1--20 1--22 1--32 2-- 3 2-- 4 2-- 8 2--14 ## [21] 2--18 2--20 2--22 2--31 3-- 4 3-- 8 3--28 3--29 3--33 3--10 ## [31] 3-- 9 3--14 4-- 8 4--13 4--14 5-- 7 5--11 6-- 7 6--11 6--17 ## [41] 7--17 9--31 9--33 9--34 10--34 14--34 15--33 15--34 16--33 16--34 ## [51] 19--33 19--34 20--34 21--33 21--34 23--33 23--34 24--26 24--28 24--33 ## [61] 24--34 24--30 25--26 25--28 25--32 26--32 27--30 27--34 28--34 29--32 ## [71] 29--34 30--33 30--34 31--33 31--34 32--33 32--34 33--34 plot(z) This looks like an undirected network, which we can verify using: is_directed(z) ## [1] FALSE 2.1 Network level: a “five number summary” A good starting point of any network analysis project is to look at some basic properties of the graph as a whole. While there are many potentially interesting properties, we’ll focus here on the the “five number summary” as suggested by Luke (2015). 2.1.1 Size Probably the most basic property of a network is its size, that is, the number of vertices and the number of edges (of course these are actually already two numbers, but well..). While igraph already reported them above (if you knew where to look), we can ask for these numbers specifically: vcount(z) ## [1] 34 ecount(z) ## [1] 78 2.1.2 Density The density of a network is the ratio of existing edges and the maximum possible number of edges that could exist, given the number of vertices. We can let R calculate it for us: edge_density(z) ## [1] 0.1390374 Obviously, we could already have calculated this ourselves, given that we already knew the number of edges and the number of vertices. QUESTION: How would you calculate density using ecount() and vcount()? If desired, we can also add such network-level results to the network object, for later use: z$density &lt;- edge_density(z) z ## IGRAPH 3895987 U--- 34 78 -- Zachary ## + attr: name (g/c), density (g/n) ## + edges from 3895987: ## [1] 1-- 2 1-- 3 1-- 4 1-- 5 1-- 6 1-- 7 1-- 8 1-- 9 1--11 1--12 ## [11] 1--13 1--14 1--18 1--20 1--22 1--32 2-- 3 2-- 4 2-- 8 2--14 ## [21] 2--18 2--20 2--22 2--31 3-- 4 3-- 8 3--28 3--29 3--33 3--10 ## [31] 3-- 9 3--14 4-- 8 4--13 4--14 5-- 7 5--11 6-- 7 6--11 6--17 ## [41] 7--17 9--31 9--33 9--34 10--34 14--34 15--33 15--34 16--33 16--34 ## [51] 19--33 19--34 20--34 21--33 21--34 23--33 23--34 24--26 24--28 24--33 ## [61] 24--34 24--30 25--26 25--28 25--32 26--32 27--30 27--34 28--34 29--32 ## [71] 29--34 30--33 30--34 31--33 31--34 32--33 32--34 33--34 ‘Density’ is now listed as one of the attributes of the object, where ‘g/n’ indicates that it is a graph-level attribute. 2.1.3 Components The number of components is the number of unconnected parts of the network (which may be parts consisting of one node, that is, isolates). The number of components in this network is, quite trivially, just one, but the way to get it is: count_components(z) ## [1] 1 2.1.4 Diameter (and distances) The diameter of a network is the “longest shortest path” in the network diameter(z) ## [1] 5 A related an much-studied property is the average shortest path length, that is, the average of all the shortest path over all pairs of vertices in the network. For example, this is the key indicator in the “small world phenomenon”. mean_distance(z) ## [1] 2.4082 2.1.5 Clustering Coefficient Clustering, or transitivity, relates to the extent to which triangles tend to be closed in the network, or put differently, to what extent neighbors of nodes tend to be connected themselves. There are many ways to quantify this tendency (which also differ for directed an undirected networks), and the transitivity() function covers many of them. Note that in the literature and elsewhere in the field, terms like ‘transitivity’ and ‘clustering’ are often used quite loosely, so it is always wise to look closely at the formal specifications (if provided) to know what is meant in a specific use case. We here compute what is most commonly known as the ‘clustering coefficient’. This computes, for each vertex, the proportion of the potential ties between the vertex’ neighbors that actually exist (in the ego networks literature, this is referred to as local density), and averages this over all vertices. transitivity(z, type=&quot;average&quot;) ## [1] 0.5879306 Interestingly, the specification of ‘average’ for the ‘type’ parameter is not explained in the igraph documentation, but this is what it does. 2.2 Individual level: centrality Moving to the individual (that is, node-level) measures, we concentrate here on centrality measures. Obviously, there are many other measures related to individual network position that may be relevant (and are included in igraph, see the reference manual). 2.2.1 Degree centrality The most straightforward measure of centrality is degree centrality, or simply the number of connections per node. We obtain it using the degree() function from igraph: degree(z) ## [1] 16 9 10 6 3 4 4 4 5 2 3 1 2 5 2 2 2 2 2 3 2 2 2 5 3 ## [26] 3 2 4 3 4 4 6 12 17 Because degree is an individual-level property, the result from the function is no longer a single number as before, but a vector of numbers, one for each node. Of course we can use this vector for further calculations: summary(degree(z)) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1.000 2.000 3.000 4.588 5.000 17.000 hist(degree(z)) (Note that there are of course much nicer and better ways to analyze and visualize distributions like this, but that is not the point of this tutorial.) In many other cases, we’d want to keep the individual-level results on centrality and add them to the network object for later use: V(z)$degree &lt;- degree(z) We may, for example, want to use it in a plot: #We add + 8 to degree to avoid that the lowest-degree nodes become really small and specify margin = -0.1 to reduce the whitespace around the plot plot(z, vertex.size = V(z)$degree+8, margin= -0.1) Finally, if you run ?degree() on your console, you’ll note that the function has a number of other useful options. For example, we can also extract the degree of a specific vertex: degree(z, v = 3) ## [1] 10 Furthermore, for directed networks, you can also specify whether you want indegree, outdegree, or the total degree (but that does not apply to our undirected example network). 2.2.2 Betweenness centrality A fancier centrality measure is betweenness centrality, which relies on the shortest paths between all pairs of vertices to assess to what extent nodes sit on shortest paths between other nodes. betweenness(z) ## [1] 231.0714286 28.4785714 75.8507937 6.2880952 0.3333333 15.8333333 ## [7] 15.8333333 0.0000000 29.5293651 0.4476190 0.3333333 0.0000000 ## [13] 0.0000000 24.2158730 0.0000000 0.0000000 0.0000000 0.0000000 ## [19] 0.0000000 17.1468254 0.0000000 0.0000000 0.0000000 9.3000000 ## [25] 1.1666667 2.0277778 0.0000000 11.7920635 0.9476190 1.5428571 ## [31] 7.6095238 73.0095238 76.6904762 160.5515873 We again add it to the network object. This time, we use set_vertex_attr() rather than V() just to demonstrate that this may work better in a “pipeline” workflow: z &lt;- z %&gt;% set_vertex_attr( name = &quot;betweenness&quot;, value = betweenness(z) ) 2.2.3 Closeness centrality Finally, we add closeness centrality, which also relies on shortest paths, but instead assesses how close each node is to the other nodes. V(z)$closeness &lt;- closeness(z) "],["introducing-the-knecht-data.html", "3 Introducing the Knecht data 3.1 A first look at the data 3.2 Assignment", " 3 Introducing the Knecht data In this tutorial, we take some real network data that we will use throughout the course. The goal is to import the data, and perform some data management tasks as we’ve done in the previous tutorials, as well as some basic analysis, but now with real data instead of “toy data”. In the first part of the tutorial, we’ll have a first look at the data and select some data to work with. The second part is an assignment in which you apply your knowledge from the previous tutorials to these data. First we need to load some packages: library(igraph) library(haven) # to read Stata files library(reshape2) library(tidyverse) 3.1 A first look at the data The data we are using is the longitudinal dataset collected by Andrea Knecht for her dissertation at Utrecht University in 2003-2004. Using questionnaires, she collected data from 3171 students in 126 first-grade classes of 14 secondary schools in the Netherlands. The students were surveyed at three-month intervals one the academic year. The survey included (among many other things) name generator questions for friendship networks, support networks, interaction networks, and a number of other networks. You can find the data file for one wave on Blackboard, under Course Content/data. Download this file and save it in the same directory as your R-script. We first load the data set (note the use of the function to import Stata’s *.dta format): PupilsWaveV &lt;- read_dta(file = &quot;PupilsWaveV.dta&quot;) The variables schoolnr and namenr represent, respectively, classes (in schools) and pupils in classes. QUESTION: Have a close look at these two variables, comparing the namenr values for different classes (just eyeballing the data should be sufficient). What do you notice? To keep things manageable for now, we select only one class: class12b &lt;- PupilsWaveV %&gt;% filter(schoolnr == &quot;12b&quot;) # keep only one class The name generator question for “best friends” asked the pupils to nominate up to 12 of their best friends in class; the resulting nominations are stored in the variables friend1, friend2,… friend12. This is the network we will work with in this tutorial (but there are many other interesting name generators in the data set!). 3.2 Assignment In the following assignment, you are asked to perform a first descriptive network analysis of the friendship network in class 12b, using the techniques in the tutorials so far. Please complete the following tasks: Import the data into an igraph network object. For the network, use the ‘friend..’ variables; for node attributes, include age and gender. TIP: First think carefully about what format the data are in, and which corresponding procedure from the ones discussed in the tutorials you’d need to import the data properly. Establish whether, from an empirical perspective, this is a directed or an undirected network. First, think about what it should be, given the data collection method, and then verify that this is indeed correct in the data. Make a first visualization of the network. Make a ‘five number summary’ of the network. Test the hypothesis that girls have higher degree than boys in this network. Visualize the network again, this time making vertex size dependent on degree, and vertex color on gender (the relevant parameter is vertex.color). What strikes you about this network? "],["networks-as-causes-spatial-regression-analysis.html", "4 Networks as causes: Spatial regression analysis", " 4 Networks as causes: Spatial regression analysis Coming soon! "],["exponential-random-graphs-modeling.html", "5 Exponential Random Graphs Modeling 5.1 Data preparation 5.2 Model estimation 5.3 Goodness of fit 5.4 Further resources on ERGMs", " 5 Exponential Random Graphs Modeling library(network) library(igraph) library(intergraph) library(sna) library(ergm) library(tidyverse) 5.1 Data preparation We’ll work with the same single class (“12b”) from the Knecht data as before. To keep things very concise here, we simply load an igraph network object that we’ve saved to disk before. load(&quot;classnet.rdata&quot;) summary(classnet) ## IGRAPH 963ef71 DN-- 26 91 -- ## + attr: name (v/c), sex (v/n), age (v/n), sourcevar (e/c) However, for exponential random graph modeling, we’ll actually need network objects from the network class (that is, as generated by the network package). For this, we’ll use the intergraph package, already loaded above. Unfortunately, network does not handle factor variables, so we first need to convert ‘sex’ to a numeric variable. V(classnet)$sex &lt;-as.numeric(V(classnet)$sex) g &lt;- asNetwork(classnet) g ## Network attributes: ## vertices = 26 ## directed = TRUE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## bipartite = FALSE ## total edges= 91 ## missing edges= 0 ## non-missing edges= 91 ## ## Vertex attribute names: ## age sex vertex.names ## ## Edge attribute names: ## sourcevar The alternative approach would be to load the original data set, filter out the class, prepare the data as an edge list and node list as we’ve done before, and then import it directly into a network object using one of the as.network...() function from the network package. gplot(g, vertex.col=g %v% &quot;sex&quot;*2) Looks like we have some gender homophily going on here, as well as a lot of reciprocity! With ERGM, we can test this statistically. 5.2 Model estimation Now let’s estimate a simple model. First we test the hypothesis that ties are likely to be reciprocated. In this case we add, besides the “edges” term, M1.g&lt;-ergm(g ~ edges + mutual ) ## Starting maximum pseudolikelihood estimation (MPLE): ## Obtaining the responsible dyads. ## Evaluating the predictor and response matrix. ## Maximizing the pseudolikelihood. ## Finished MPLE. ## Starting Monte Carlo maximum likelihood estimation (MCMLE): ## Iteration 1 of at most 60: ## Warning: &#39;glpk&#39; selected as the solver, but package &#39;Rglpk&#39; is not available; ## falling back to &#39;lpSolveAPI&#39;. This should be fine unless the sample size and/or ## the number of parameters is very big. ## Optimizing with step length 1.0000. ## The log-likelihood improved by 0.0296. ## Convergence test p-value: 0.0043. Converged with 99% confidence. ## Finished MCMLE. ## Evaluating log-likelihood at the estimate. Fitting the dyad-independent submodel... ## Bridging between the dyad-independent submodel and the full model... ## Setting up bridge sampling... ## Using 16 bridges: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 . ## Bridging finished. ## ## This model was fit using MCMC. To examine model diagnostics and check ## for degeneracy, use the mcmc.diagnostics() function. summary(M1.g) ## Call: ## ergm(formula = g ~ edges + mutual) ## ## Monte Carlo Maximum Likelihood Results: ## ## Estimate Std. Error MCMC % z value Pr(&gt;|z|) ## edges -2.7126 0.1922 0 -14.113 &lt;1e-04 *** ## mutual 3.2421 0.4436 0 7.308 &lt;1e-04 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Null Deviance: 901.1 on 650 degrees of freedom ## Residual Deviance: 455.4 on 648 degrees of freedom ## ## AIC: 459.4 BIC: 468.4 (Smaller is better. MC Std. Err. = 0.8174) Indeed, we find a positive and significant effect for the number of reciprocated ties. Now let’s add the homophily effect (as well as a gender differential effect): M2.g&lt;-ergm(g ~ edges + mutual + nodefactor(&quot;sex&quot;, levels = 2) + nodematch(&quot;sex&quot; )) summary(M2.g) ## Call: ## ergm(formula = g ~ edges + mutual + nodefactor(&quot;sex&quot;, levels = 2) + ## nodematch(&quot;sex&quot;)) ## ## Monte Carlo Maximum Likelihood Results: ## ## Estimate Std. Error MCMC % z value Pr(&gt;|z|) ## edges -3.7697 0.3080 0 -12.241 &lt;1e-04 *** ## mutual 2.8488 0.4189 0 6.801 &lt;1e-04 *** ## nodefactor.sex.2 0.1979 0.1202 0 1.647 0.0996 . ## nodematch.sex 1.4778 0.2968 0 4.980 &lt;1e-04 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Null Deviance: 901.1 on 650 degrees of freedom ## Residual Deviance: 416.5 on 646 degrees of freedom ## ## AIC: 424.5 BIC: 442.4 (Smaller is better. MC Std. Err. = 0.7361) Indeed, we find a positive effect of gender homophily. 5.3 Goodness of fit Finally, let’s look at goodness of fit: M2.g.gof &lt;- gof(M2.g) M2.g.gof ## ## Goodness-of-fit for in-degree ## ## obs min mean max MC p-value ## idegree0 0 0 0.61 3 1.00 ## idegree1 4 0 2.50 7 0.50 ## idegree2 7 1 4.37 9 0.38 ## idegree3 4 3 6.36 12 0.38 ## idegree4 1 1 5.27 13 0.02 ## idegree5 6 0 3.76 10 0.38 ## idegree6 1 0 2.05 7 0.74 ## idegree7 3 0 0.77 4 0.12 ## idegree8 0 0 0.20 2 1.00 ## idegree9 0 0 0.09 1 1.00 ## idegree11 0 0 0.01 1 1.00 ## idegree12 0 0 0.01 1 1.00 ## ## Goodness-of-fit for out-degree ## ## obs min mean max MC p-value ## odegree0 1 0 0.55 2 0.86 ## odegree1 4 0 2.30 7 0.42 ## odegree2 4 1 5.00 12 0.88 ## odegree3 5 2 6.13 12 0.82 ## odegree4 6 1 5.40 10 0.84 ## odegree5 3 0 3.40 7 0.96 ## odegree6 0 0 1.94 6 0.34 ## odegree7 1 0 0.86 6 1.00 ## odegree8 1 0 0.26 2 0.46 ## odegree9 0 0 0.11 2 1.00 ## odegree10 1 0 0.04 1 0.08 ## odegree11 0 0 0.01 1 1.00 ## ## Goodness-of-fit for edgewise shared partner ## ## obs min mean max MC p-value ## esp.OTP0 19 32 48.48 68 0.00 ## esp.OTP1 24 12 29.60 58 0.62 ## esp.OTP2 27 1 9.98 25 0.00 ## esp.OTP3 14 0 2.17 10 0.00 ## esp.OTP4 6 0 0.25 6 0.02 ## esp.OTP5 1 0 0.05 1 0.10 ## ## Goodness-of-fit for minimum geodesic distance ## ## obs min mean max MC p-value ## 1 91 68 90.53 121 0.96 ## 2 104 105 188.84 271 0.00 ## 3 80 112 189.30 243 0.00 ## 4 57 48 96.66 145 0.08 ## 5 48 1 33.73 83 0.52 ## 6 18 0 11.60 70 0.48 ## 7 5 0 3.64 49 0.42 ## 8 0 0 1.05 20 1.00 ## 9 0 0 0.32 9 1.00 ## 10 0 0 0.07 5 1.00 ## 11 0 0 0.01 1 1.00 ## Inf 247 0 34.25 178 0.00 ## ## Goodness-of-fit for model statistics ## ## obs min mean max MC p-value ## edges 91 68 90.53 121 0.96 ## mutual 28 16 27.90 44 1.00 ## nodefactor.sex.2 58 33 57.79 86 1.00 ## nodematch.sex 79 57 78.60 107 0.96 This looks OK for the model statistics, but less so for the for network statistics not in the model. Let’s have a closer look at those: plot(M2.g.gof) Indeed, some of these are quite off, indicating that we might want to include some other effects in the model. Indeed, for directed networks, it is common to include at least somethign related to degree, reciprocity, and something related to triadic closure. The exact choice of effects is not trivial though and may lead to compuational complications, so we leave it at this for now. 5.4 Further resources on ERGMs For further introductions to ERGM, we suggest this tutorial by the Statnet team and this tutorial by Rawlings et al. The latter in particular has an informative illustration of the inclusion of triadic effects and the computational issues involved. Also helpful is this short list of common ERGM terms. A longer list is here. "],["a-deeper-dive-into-data-handling-complications-in-name-generator-data.html", "6 A deeper dive into data handling: complications in name generator data 6.1 The case of the missing ego 6.2 Multiple networks", " 6 A deeper dive into data handling: complications in name generator data In a previous tutorial, we’ve covered processing ‘adjacency list’ data, as typically generated by surveys with name generator questions, as network data. With real-life data, such data sets often have quirks that can create havoc in your data processing procedures if you’re not carefull. In the earlie tutorial, we already discussed one such quirk, namely the presences of isolates. In this tutorial, we cover two more challenges: The presence of alters who are missing as respondents (egos); The processing of multiple subnetworks (in our scenario: school classes) at the same time. Let’s get started. For practice, we use a toy dataset that was designed for looking just like the Knecht data (but smaller). df &lt;- read.csv(&quot;toy_name_generator_data.csv&quot;) table(df$schoolnr) ## ## 1a 2b ## 5 5 df ## schoolnr namenr age friend1 friend2 ## 1 1a 1 20 2 4 ## 2 1a 2 21 3 NA ## 3 1a 3 25 1 NA ## 4 1a 4 NA NA NA ## 5 1a 5 21 NA NA ## 6 2b 1 22 2 3 ## 7 2b 2 24 1 3 ## 8 2b 3 NA NA 4 ## 9 2b 4 21 2 5 ## 10 2b 5 20 6 NA 6.1 The case of the missing ego Let’s start with importing one class, as before: cls &lt;- &quot;1a&quot; edge_list &lt;- df %&gt;% filter(schoolnr == cls) %&gt;% select(namenr, friend1:friend2) %&gt;% melt(id.vars = &quot;namenr&quot;) %&gt;% #make long filter(!is.na(value)) %&gt;% # drop the missings rename(from =&quot;namenr&quot;, to = &quot;value&quot;, sourcevar= &quot;variable&quot;) %&gt;% #just nice for interpretation relocate(to, .after=from) #move around the columns edge_list ## from to sourcevar ## 1 1 2 friend1 ## 2 2 3 friend1 ## 3 3 1 friend1 ## 4 1 4 friend2 nodelist &lt;- df %&gt;% filter(schoolnr == cls) %&gt;% select(namenr,age) g1a &lt;- graph_from_data_frame(edge_list, vertices = nodelist) plot(g1a) So far, so good. Now let’s try with the other class: cls &lt;- &quot;2b&quot; edge_list &lt;- df %&gt;% filter(schoolnr == cls) %&gt;% select(namenr, friend1:friend2) %&gt;% melt(id.vars = &quot;namenr&quot;) %&gt;% #make long filter(!is.na(value)) %&gt;% # drop the missings rename(from =&quot;namenr&quot;, to = &quot;value&quot;, sourcevar= &quot;variable&quot;) %&gt;% #just nice for interpretation relocate(to, .after=from) #move around the columns edge_list ## from to sourcevar ## 1 1 2 friend1 ## 2 2 1 friend1 ## 3 4 2 friend1 ## 4 5 6 friend1 ## 5 1 3 friend2 ## 6 2 3 friend2 ## 7 3 4 friend2 ## 8 4 5 friend2 nodelist &lt;- df %&gt;% filter(schoolnr == cls) %&gt;% select(namenr,age) g2b &lt;- graph_from_data_frame(edge_list, vertices = nodelist) ## Error in graph_from_data_frame(edge_list, vertices = nodelist): Some vertex names in edge list are not listed in vertex data frame Problem: Now this leads to an error, as there is a vertex nominated as friend who is not in the data as an ‘ego’. The igraph function graph_from_data_frame() does not allow this. QUESTION: What is a plausible data collection scenario under which this could happen? Solution: We need to fix the node list to include this missing vertex. First let’s create a list of all the vertices that appear in the edge list: all_vertices &lt;- append(edge_list$from, edge_list$to) Then, we remove duplicates: all_vertices &lt;- unique(all_vertices) %&gt;% as.data.frame() %&gt;% rename(namenr = &quot;.&quot;) nodelist &lt;- df %&gt;% filter(schoolnr == cls) %&gt;% select(namenr,age, schoolnr) %&gt;% merge(all_vertices, by = &quot;namenr&quot;, all.y = T) nodelist ## namenr age schoolnr ## 1 1 22 2b ## 2 2 24 2b ## 3 3 NA 2b ## 4 4 21 2b ## 5 5 20 2b ## 6 6 NA &lt;NA&gt; We now have a node list that includes all the nodes. Obviously, ‘age’ is missing for node 6 in these data, as node 6 was not included as a respondent in the data in the first place. However, ‘schoolnr’ is also missing, even if we know that node 6 was in this class too. So let’s fix that: nodelist &lt;- nodelist %&gt;% replace_na(list(schoolnr = cls)) nodelist ## namenr age schoolnr ## 1 1 22 2b ## 2 2 24 2b ## 3 3 NA 2b ## 4 4 21 2b ## 5 5 20 2b ## 6 6 NA 2b g2b &lt;- graph_from_data_frame(edge_list, vertices = nodelist) plot(g2b) 6.2 Multiple networks Now let’s try to import the two classes into a network object at once, as if they are a single network. edge_list &lt;- df %&gt;% select(namenr, friend1:friend2) %&gt;% melt(id.vars = &quot;namenr&quot;) %&gt;% #make long filter(!is.na(value)) %&gt;% # drop the missings rename(from =&quot;namenr&quot;, to = &quot;value&quot;, sourcevar= &quot;variable&quot;) %&gt;% #just nice for interpretation relocate(to, .after=from) #move around the columns all_vertices &lt;- append(edge_list$from, edge_list$to) %&gt;% unique() %&gt;% as.data.frame() %&gt;% rename(namenr = &quot;.&quot;) nodelist &lt;- df %&gt;% select(namenr,age, schoolnr) %&gt;% merge(all_vertices, by = &quot;namenr&quot;, all.y = T, all.x = T) g2 &lt;- graph_from_data_frame(edge_list, vertices = nodelist) ## Error in graph_from_data_frame(edge_list, vertices = nodelist): Duplicate vertex names Houston, we’ve got a problem. We need to be able to differentiate between the nodes from different classes, both for repondents (“egos”) and nominees (“alters”). Let’s start with the ego, which is the simplest case. We can create a unique student ID by combining the class identifier and the within-class identifier: df &lt;- df %&gt;% mutate(id_pupil = paste0(schoolnr,namenr)) Now let’s start over, using this new identifier instead of ‘namenr’. edge_list &lt;- df %&gt;% select(id_pupil, schoolnr, friend1:friend2) %&gt;% melt(id.vars = c(&quot;id_pupil&quot;,&quot;schoolnr&quot;)) %&gt;% #make long filter(!is.na(value)) %&gt;% # drop the missings rename(from =&quot;id_pupil&quot;, to = &quot;value&quot;, sourcevar= &quot;variable&quot;) %&gt;% #just nice for interpretation relocate(to, .after=from) #move around the columns edge_list ## from to schoolnr sourcevar ## 1 1a1 2 1a friend1 ## 2 1a2 3 1a friend1 ## 3 1a3 1 1a friend1 ## 4 2b1 2 2b friend1 ## 5 2b2 1 2b friend1 ## 6 2b4 2 2b friend1 ## 7 2b5 6 2b friend1 ## 8 1a1 4 1a friend2 ## 9 2b1 3 2b friend2 ## 10 2b2 3 2b friend2 ## 11 2b3 4 2b friend2 ## 12 2b4 5 2b friend2 Now we can also create the unique student ID for alters in the ‘to’ column of the edge list: edge_list &lt;- edge_list %&gt;% mutate(to = paste0(schoolnr,to)) edge_list ## from to schoolnr sourcevar ## 1 1a1 1a2 1a friend1 ## 2 1a2 1a3 1a friend1 ## 3 1a3 1a1 1a friend1 ## 4 2b1 2b2 2b friend1 ## 5 2b2 2b1 2b friend1 ## 6 2b4 2b2 2b friend1 ## 7 2b5 2b6 2b friend1 ## 8 1a1 1a4 1a friend2 ## 9 2b1 2b3 2b friend2 ## 10 2b2 2b3 2b friend2 ## 11 2b3 2b4 2b friend2 ## 12 2b4 2b5 2b friend2 The result is a neat list of within-class ties. We continue with creating the node list: all_vertices &lt;- append(edge_list$from, edge_list$to) %&gt;% unique() %&gt;% as.data.frame() %&gt;% rename(id_pupil = &quot;.&quot;) nodelist &lt;- df %&gt;% select(id_pupil,age, schoolnr) %&gt;% merge(all_vertices, by = &quot;id_pupil&quot;, all.y = T, all.x = T) g2 &lt;- graph_from_data_frame(edge_list, vertices = nodelist) plot(g2, vertex.color = ifelse(V(g2)$schoolnr==&quot;1a&quot;, &quot;lightblue&quot;, &quot;red&quot;)) Almost correct! The one thing to fix is that now we don’t have the schoolnr for node 2b6. The approach that we used earlier doesn’t work now (why not?), but recall that we already have schoolnr for each edge in ‘edge_list’. We use that to keep schoolnr with the list of all vertices (all_vertices) and keep it in the merge with the node list. The method for constructing all_vertices is a little different now. all_vertices &lt;- edge_list %&gt;% select(id_pupil = from, schoolnr) %&gt;% bind_rows(edge_list %&gt;% select(id_pupil = to, schoolnr)) %&gt;% unique() %&gt;% rename(schoolnr_from_edges = schoolnr) nodelist &lt;- df %&gt;% select(id_pupil,age, schoolnr) %&gt;% merge(all_vertices, by = &quot;id_pupil&quot;, all.y = T, all.x = T) We now replace any NA’s in schoolnr with the value in schoolnr_from_edges. For tidiness, we remove schoolnr_from_edges as we don’t need it to be imported in our network object (of course there may be scenarios where you may want to keep it). nodelist &lt;- nodelist %&gt;% mutate(schoolnr = coalesce(schoolnr,schoolnr_from_edges)) %&gt;% select(-schoolnr_from_edges) g2 &lt;- graph_from_data_frame(edge_list, vertices = nodelist) plot(g2, vertex.color = ifelse(V(g2)$schoolnr==&quot;1a&quot;, &quot;lightblue&quot;, &quot;red&quot;)) Done! "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
