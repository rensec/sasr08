# A deeper dive into data handling: complications in name generator data

In a previous tutorial, we've covered processing 'adjacency list' data, as typically generated by surveys with name generator questions, as network data. With real-life data, such data sets often have quirks that can create havoc in your data processing procedures if you're not carefull. In the earlie tutorial, we already discussed one such quirk, namely the presences of isolates. In this tutorial, we cover two more challenges:

1.    The presence of alters who are missing as respondents (egos);
2.    The processing of multiple subnetworks (in our scenario: school classes) at the same time.


Let's get started.

```{r, echo=FALSE, message=FALSE}
library(igraph)
library(tidyverse)
library(reshape2)
```


For practice, we use a toy dataset that was designed for looking just like the Knecht data (but smaller).

```{r}
df <- read.csv("toy_name_generator_data.csv")
table(df$schoolnr)
df

```



## The case of the missing ego

Let's start with importing one class, as before:


```{r}
cls <- "1a"
edge_list <- df %>% 
  filter(schoolnr == cls) %>% 
  select(namenr, friend1:friend2) %>% 
  melt(id.vars = "namenr") %>% #make long
  filter(!is.na(value)) %>% # drop the missings
  rename(from ="namenr", to = "value", sourcevar= "variable") %>% #just nice for interpretation
  relocate(to, .after=from) #move around the columns
edge_list
```


```{r}
nodelist <- df %>% 
  filter(schoolnr == cls) %>% 
  select(namenr,age)

g1a <- graph_from_data_frame(edge_list, vertices = nodelist)
plot(g1a)
```

So far, so good.

Now let's try with the other class:


```{r}
cls <- "2b"
edge_list <- df %>% 
  filter(schoolnr == cls) %>% 
  select(namenr, friend1:friend2) %>% 
  melt(id.vars = "namenr") %>% #make long
  filter(!is.na(value)) %>% # drop the missings
  rename(from ="namenr", to = "value", sourcevar= "variable") %>% #just nice for interpretation
  relocate(to, .after=from) #move around the columns
edge_list
```


```{r, error=TRUE}
nodelist <- df %>% 
  filter(schoolnr == cls) %>% 
  select(namenr,age)

g2b <- graph_from_data_frame(edge_list, vertices = nodelist) 

```
***Problem:*** Now this leads to an error, as there is a vertex nominated as friend who is not in the data as an 'ego'. The `igraph` function `graph_from_data_frame()` does not allow this. 

***QUESTION: What is a plausible data collection scenario under which this could happen? ***

***Solution:*** We need to fix the node list to include this missing vertex. First let's create a list of all the vertices that appear in the edge list:

```{r}
all_vertices <- append(edge_list$from, edge_list$to)
```

Then, we remove duplicates: 
```{r}
all_vertices <- unique(all_vertices) %>% 
  as.data.frame() %>% 
  rename(namenr = ".")
```

```{r}

nodelist <- df %>% 
  filter(schoolnr == cls) %>% 
  select(namenr,age, schoolnr) %>% 
  merge(all_vertices, by = "namenr", all.y = T)

nodelist
```

We now have a node list that includes *all* the nodes. Obviously, 'age' is missing for node 6 in these data, as node 6 was not included as a respondent in the data in the first place. However, 'schoolnr' is also missing, even if we *know* that node 6 was in this class too. So let's fix that:

```{r}

nodelist <- nodelist %>% 
  replace_na(list(schoolnr = cls))

nodelist
```


```{r}
g2b <- graph_from_data_frame(edge_list, vertices = nodelist) 
plot(g2b)
```

## Multiple networks

Now let's try to import the two classes into a network object *at once*, as if they are a single network. 

```{r, error=TRUE}

edge_list <- df %>% 
  select(namenr, friend1:friend2) %>% 
  melt(id.vars = "namenr") %>% #make long
  filter(!is.na(value)) %>% # drop the missings
  rename(from ="namenr", to = "value", sourcevar= "variable") %>% #just nice for interpretation
  relocate(to, .after=from) #move around the columns

all_vertices <- append(edge_list$from, edge_list$to) %>% 
  unique() %>% 
  as.data.frame() %>% 
  rename(namenr = ".")


nodelist <- df %>% 
  select(namenr,age, schoolnr) %>% 
  merge(all_vertices, by = "namenr", all.y = T, all.x = T)

g2 <- graph_from_data_frame(edge_list, vertices = nodelist) 


```

Houston, we've got a problem. 

We need to be able to differentiate between the nodes from different classes, both for repondents ("egos") and nominees ("alters"). Let's start with the ego, which is the simplest case. We can create a unique student ID by combining the class identifier and the within-class identifier:

```{r}
df <- df %>% 
  mutate(id_pupil = paste0(schoolnr,namenr))
```

Now let's start over, using this new identifier instead of 'namenr'.

```{r}
edge_list <- df %>% 
  select(id_pupil, schoolnr, friend1:friend2) %>% 
  melt(id.vars = c("id_pupil","schoolnr")) %>% #make long
  filter(!is.na(value)) %>% # drop the missings
  rename(from ="id_pupil", to = "value", sourcevar= "variable") %>% #just nice for interpretation
  relocate(to, .after=from) #move around the columns
edge_list


```

Now we can also create the unique student ID for alters in the 'to' column of the edge list:

```{r}
edge_list <- edge_list %>% 
  mutate(to = paste0(schoolnr,to))
edge_list
```
The result is a neat list of within-class ties. We continue with creating the node list: 

```{r}
all_vertices <- append(edge_list$from, edge_list$to) %>% 
  unique() %>% 
  as.data.frame() %>% 
  rename(id_pupil = ".")


nodelist <- df %>% 
  select(id_pupil,age, schoolnr) %>% 
  merge(all_vertices, by = "id_pupil", all.y = T, all.x = T)

```

```{r}
g2 <- graph_from_data_frame(edge_list, vertices = nodelist) 
plot(g2, vertex.color = ifelse(V(g2)$schoolnr=="1a", "lightblue", "red"))
```

Almost correct! The one thing to fix is that now we don't have the schoolnr for node 2b6. The approach that we used earlier doesn't work now (why not?), but recall that we already have schoolnr for each edge in 'edge_list'. We use that to keep schoolnr with the list of all vertices (all_vertices) and keep it in the merge with the node list. The method for constructing `all_vertices` is a little different now. 

```{r}

all_from <- select(edge_list, from,schoolnr) %>% 
  rename(id_pupil = "from")
all_to <- select(edge_list,to, schoolnr) %>% 
  rename(id_pupil = "to")

all_vertices <- rbind(all_to, all_from)   %>% 
  unique() %>% 
  rename(schoolnr_from_edges = "schoolnr")
  
nodelist <- df %>% 
  select(id_pupil,age, schoolnr) %>% 
  merge(all_vertices, by = "id_pupil", all.y = T, all.x = T)

```

We now replace any NA's in schoolnr with the value in schoolnr_from_edges. For tidiness, we remove schoolnr_from_edges as we don't need it to be imported in our network object (of course there may be scenarios where you may want to keep it). 

```{r}
nodelist <- nodelist %>% 
  mutate(schoolnr = coalesce(schoolnr,schoolnr_from_edges)) %>% 
  select(-schoolnr_from_edges)

g2 <- graph_from_data_frame(edge_list, vertices = nodelist) 
plot(g2, vertex.color = ifelse(V(g2)$schoolnr=="1a", "lightblue", "red"))

```

Done!
