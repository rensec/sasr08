# A deeper dive into data handling: complications in name generator data

In a previous tutorial, we've covered processing 'adjacency list' data, as typically generated by surveys with name generator questions, as network data. With real-life data, such data sets often have quirks that can create havoc in your data processing procedures if you're not carefull. In the earlie tutorial, we already discussed one such quirk, namely the presences of isolates. In this tutorial, we cover two more challenges:

1.    The presence of alters who are missing as respondents (egos);
2.    The processing of multiple subnetworks (in our scenario: school classes) at the same time.


Let's get started.

```{r, echo=FALSE, message=FALSE}
library(igraph)
library(tidyverse)
library(reshape2)
library(network)
```


For practice, we use a toy dataset that was designed for looking just like the Knecht data (but smaller).

```{r}
url1 <- "https://github.com/rensec/sasr08/raw/main/toy_name_generator_data.csv"
df <- read.csv(file = url1)
table(df$schoolnr)
df

```



## The case of the missing ego

Let's start with importing one class, as before:


```{r}
cls <- "1a"
edge_list <- df %>% 
  filter(schoolnr == cls) %>% 
  select(namenr, friend1:friend2) %>% 
  melt(id.vars = "namenr") %>% #make long
  filter(!is.na(value)) %>% # drop the missings
  rename(from ="namenr", to = "value", sourcevar= "variable") %>% #just nice for interpretation
  relocate(to, .after=from) #move around the columns
edge_list
```


```{r}
nodelist <- df %>% 
  filter(schoolnr == cls) %>% 
  select(namenr,age)

g1a <- graph_from_data_frame(edge_list, vertices = nodelist)
plot(g1a)
```

So far, so good.

Now let's try with the other class:


```{r}
cls <- "2b"
edge_list <- df %>% 
  filter(schoolnr == cls) %>% 
  select(namenr, friend1:friend2) %>% 
  melt(id.vars = "namenr") %>% #make long
  filter(!is.na(value)) %>% # drop the missings
  rename(from ="namenr", to = "value", sourcevar= "variable") %>% #just nice for interpretation
  relocate(to, .after=from) #move around the columns
edge_list
```


```{r, error=TRUE}
nodelist <- df %>% 
  filter(schoolnr == cls) %>% 
  select(namenr,age)

g2b <- graph_from_data_frame(edge_list, vertices = nodelist) 

```
***Problem:*** Now this leads to an error, as there is a vertex nominated as friend who is not in the data as an 'ego'. The `igraph` function `graph_from_data_frame()` does not allow this. 

***QUESTION: What is a plausible data collection scenario under which this could happen? ***

***Solution:*** We need to fix the node list to include this missing vertex. First let's create a list of all the vertices that appear in the edge list:

```{r}
all_vertices <- append(edge_list$from, edge_list$to)
```

Then, we remove duplicates: 
```{r}
all_vertices <- unique(all_vertices) %>% 
  as.data.frame() %>% 
  rename(namenr = ".")
```

Next, we create a node list that includes all the vertices, by combining the list of nodes from the original data set with the list of vertices from the edge list. We do this by merging the two data sets, using the `merge()` function.

```{r}

nodelist <- df %>% 
  filter(schoolnr == cls) %>% 
  select(namenr,age, schoolnr) %>% 
  merge(all_vertices, by = "namenr", all.y = T, all.x = T)

nodelist
```

We now have a node list that includes *all* the nodes. Obviously, 'age' is missing for node 6 in these data, as node 6 was not included as a respondent in the data in the first place. However, 'schoolnr' is also missing, even if we *know* that node 6 was in this class too. So let's fix that:

```{r}

nodelist <- nodelist %>% 
  replace_na(list(schoolnr = cls))

nodelist
```


```{r}
g2b <- graph_from_data_frame(edge_list, vertices = nodelist) 
plot(g2b)
```

## Double mentions

Let's look at a variation of our toy data set, called toy_data_generator_data_2.csv.

```{r}
url1 <- "toy_name_generator_data_2.csv"
df2 <- read.csv(file = url1)
table(df2$schoolnr)
df2

```

We create an edge list:
```{r}

edge_list_3a <- df2 %>% 
    select(namenr, friend1:friend2) %>% 
  melt(id.vars = "namenr") %>% #make long
  filter(!is.na(value)) %>% # drop the missings
  rename(from ="namenr", to = "value", sourcevar= "variable") %>% #just nice for interpretation
  relocate(to, .after=from) #move around the columns
edge_list_3a
```

...and the nodes list:
```{r}
nodelist_3a <- df2 %>% 
  select(namenr,age)

g3a <- graph_from_data_frame(edge_list_3a, vertices = nodelist_3a)
plot(g3a)
```

Now we see something strange: there are two edges from node 2 to node 3. 

This even leads to problems when we try to create a network object using the `network` package:

```{r}
g3a_nw <- as.network(edge_list_3a, matrix.type = "edgelist", vertices = nodelist_3a)
```

The problem here is that node two nominates the same alter (node 3 in this case) twice. This should normally not happen with a name generator question; it could (in real data) be a mistake by the respondent or a mistake in data entry. It is however something to fix, in most cases. To do so, we select only the rows of the edge list that are unique on "from" and "to". 

```{r}
edge_list_3a <- edge_list_3a %>% 
  distinct(from, to, .keep_all = TRUE)
```

Note: we somewhat arbitrarily keep only the first occurrence of the duplicate friend. If the information in `sourcevar` is meaningful, this choice may matter. 

Now that the problem is fixed, we can properly import the data into a `network` object.

```{r}
g3a_nw <- as.network(edge_list_3a, matrix.type = "edgelist", vertices = nodelist_3a)
plot(g3a_nw)
```

## Multiple networks

Now let's try to import the two classes into a network object *at once*, as if they are a single network. 

```{r, error=TRUE}

edge_list <- df %>% 
  select(namenr, friend1:friend2) %>% 
  melt(id.vars = "namenr") %>% #make long
  filter(!is.na(value)) %>% # drop the missings
  rename(from ="namenr", to = "value", sourcevar= "variable") %>% #just nice for interpretation
  relocate(to, .after=from) #move around the columns

all_vertices <- append(edge_list$from, edge_list$to) %>% 
  unique() %>% 
  as.data.frame() %>% 
  rename(namenr = ".")


nodelist <- df %>% 
  select(namenr,age, schoolnr) %>% 
  merge(all_vertices, by = "namenr", all.y = T, all.x = T)

g2 <- graph_from_data_frame(edge_list, vertices = nodelist) 


```

Houston, we've got a problem. 

We need to be able to differentiate between the nodes from different classes, both for repondents ("egos") and nominees ("alters"). Let's start with the ego, which is the simplest case. We can create a unique student ID by combining the class identifier and the within-class identifier:

```{r}
df <- df %>% 
  mutate(id_pupil = paste0(schoolnr,namenr))
```

Now let's start over, using this new identifier instead of 'namenr'.

```{r}
edge_list <- df %>% 
  select(id_pupil, schoolnr, friend1:friend2) %>% 
  melt(id.vars = c("id_pupil","schoolnr")) %>% #make long
  filter(!is.na(value)) %>% # drop the missings
  rename(from ="id_pupil", to = "value", sourcevar= "variable") %>% #just nice for interpretation
  relocate(to, .after=from) #move around the columns
edge_list


```

Now we can also create the unique student ID for alters in the 'to' column of the edge list:

```{r}
edge_list <- edge_list %>% 
  mutate(to = paste0(schoolnr,to))
edge_list
```
The result is a neat list of within-class ties. We continue with creating the node list: 

```{r}
all_vertices <- append(edge_list$from, edge_list$to) %>% 
  unique() %>% 
  as.data.frame() %>% 
  rename(id_pupil = ".")


nodelist <- df %>% 
  select(id_pupil,age, schoolnr) %>% 
  merge(all_vertices, by = "id_pupil", all.y = T, all.x = T)

```

```{r}
g2 <- graph_from_data_frame(edge_list, vertices = nodelist) 
plot(g2, vertex.color = ifelse(V(g2)$schoolnr=="1a", "lightblue", "red"))
```

Almost correct! The one thing to fix is that now we don't have the schoolnr for node 2b6. The approach that we used earlier doesn't work now (why not?), but recall that we already have schoolnr for each edge in 'edge_list'. We use that to keep schoolnr with the list of all vertices (all_vertices) and keep it in the merge with the node list. The method for constructing `all_vertices` is a little different now. 

```{r}
all_vertices <- edge_list %>%
  select(id_pupil = from, schoolnr) %>%
  bind_rows(edge_list %>%
        select(id_pupil = to, schoolnr)) %>%
  unique() %>%
  rename(schoolnr_from_edges = schoolnr)

nodelist <- df %>% 
  select(id_pupil,age, schoolnr) %>% 
  merge(all_vertices, by = "id_pupil", all.y = T, all.x = T)

```

We now replace any NA's in schoolnr with the value in schoolnr_from_edges. For tidiness, we remove schoolnr_from_edges as we don't need it to be imported in our network object (of course there may be scenarios where you may want to keep it). 

```{r}
nodelist <- nodelist %>% 
  mutate(schoolnr = coalesce(schoolnr,schoolnr_from_edges)) %>% 
  select(-schoolnr_from_edges)

g2 <- graph_from_data_frame(edge_list, vertices = nodelist) 
plot(g2, vertex.color = ifelse(V(g2)$schoolnr=="1a", "lightblue", "red"))

```

Done!

```{r, child=c('dyads-as-cases.rmd'), echo=FALSE}  
```
