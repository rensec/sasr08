---
title: "SaSR08: Data origami with relational data"
subtitle: "Examples of common data handling procedures"
author: "Rense Corten, Utrecht University"
date: May 10, 2023
output: html_notebook
---

# Introduction

This R notebook demonstrates some data handling procedures for relational (social network) data, especially data as generated by "name generator" questionnaires.

```{r eval = FALSE, echo=false, message=false}
library(network)
library(igraph)
library(reshape2)
library(tidyverse)
```

First we load some toy data. For this we "source" (that is, run) our R-script that produces a simple small data set. The code assumes this script is in the current working directory.

```{r}

source("sasr_08_toy_data.r")
toy_data
```

This format is what we technically call an *adjacency list*. Let's add some variable labels for clarity:

```{r}
 attr(toy_data$id, "label") <- "Respondent id"
 attr(toy_data$age, "label") <- "Respondent age"
 attr(toy_data$friend1, "label") <- "1st friend"
 attr(toy_data$friend2, "label") <- "2nd friend"
```

# Edgelists

To create an edgelist, we first make the data *long*.

```{r}

net_list <- toy_data %>% 
  select(id, friend1:friend2) %>% #keep only the network variables (and id)
  melt( id.vars = "id") #from the reshape2 package
net_list

```

We can do the same using the tidyr package:

```{r}
toy_data %>% # (we don't save it into an object as above this time, since we just want to show that the result is the same)
  select(id, friend1:friend2) %>% #keep only the network variables (and id)
  pivot_longer(c(friend1, friend2))
```

To create an edgelist we drop all missing values on "value" and do some housekeeping:

```{r}
edgelist <- net_list %>% 
  #select(id, value) %>% # select the vars
  filter(!is.na(value)) %>% # drop the missings
  rename(from ="id", to = "value", sourcevar= "variable") %>% #just nice for interpretation
  relocate(to, .after=from) #move around the columns
edgelist
```

We can now interpret each {from,to} combination as a directed edge (tie) from repondent to alter; sourcevar is an *edge attribute* indicating where in the adjacency list columns the alter was mentioned. Strictly speaking you don't need the latter for a simple edgelist, but it's useful to keep in case you want to reverse the procedure.

## From edgelist to igraph object

Now we can import this into a network object using one of the network analysis packages, such as igraph:

```{r}
graph_1 <- graph_from_data_frame(edgelist) #This is a proper igraph graph objec
plot(graph_1)
```

Note however that we lost the isolate! To include the isolate, we need to feed the function also the list of *all* the nodes:

```{r}
nodelist <- select(toy_data,id,age)
graph_2 <- graph_from_data_frame(edgelist, vertices = nodelist) #This is a proper igraph graph object
plot(graph_2)
```

That's better! Note that besides the node IDs, we also include the age variable in the network object as a node attribute, such that we could use it in analyses based on the network object.

## From edgelist to network package object

We can also import it into a network object using the network package (as used by the sna and ergm packages).

```{r}
graph_3 <- as.network(edgelist, matrix.type = "edgelist", vertices = nodelist)
graph_3


```

```{r}
plot(graph_3)
```

## Back to an edgelist from igraph

```{r}
edgelist_2 <- igraph::as_data_frame(graph_2, what = "edges")
nodelist_2 <- igraph::as_data_frame(graph_2, what = "vertices")
# Note the use of the "namespace" "igraph::" here, to indicate that we need the igraph function here, not the function with the same name from the dplyr/tidyverse package

d <- edgelist_2 %>%
  rename(id = "from") %>% 
  pivot_wider( id_cols = id, names_from = sourcevar, values_from = to ) %>% 
  merge(nodelist_2, by.x = "id", by.y = "name", all.y = TRUE ) %>% 
  relocate(age, .after = id) %>% 
  type_convert() #as_data_frame returns characters; this transforms it back to numeric

d
```

...and we're back!
